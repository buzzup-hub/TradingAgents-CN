# TradingView API 客户端快速入门指南

## 前言

本指南旨在帮助新手快速上手TradingView API客户端，通过简单的步骤和示例，让您能够迅速开始使用这个强大的工具获取市场数据和技术指标。

## 第一步：准备环境

### 安装依赖

首先确保已安装Python 3.7+和必要的依赖：

```bash
pip install websockets requests
```

### 获取认证信息

使用TradingView API需要获取认证信息：

1. 登录到TradingView网站(https://www.tradingview.com/)
2. 打开浏览器开发者工具(按F12)
3. 在控制台中执行以下命令：
   ```javascript
   console.log(JSON.stringify({
     session: window.initData.user.session_token,
     signature: window.initData.user.auth_token
   }));
   ```
4. 复制输出的信息，包含session和signature值

### 设置环境变量

将认证信息设置为环境变量（推荐方式）：

```bash
# Linux/Mac
export TV_SESSION=您的session值
export TV_SIGNATURE=您的signature值

# Windows (CMD)
set TV_SESSION=您的session值
set TV_SIGNATURE=您的signature值

# Windows (PowerShell)
$env:TV_SESSION="您的session值"
$env:TV_SIGNATURE="您的signature值"
```

## 第二步：创建基本脚本

创建一个名为`first_example.py`的文件，内容如下：

```python
#!/usr/bin/env python3
import asyncio
import os
from tradingview import Client

async def main():
    # 创建客户端
    client = Client(
        token=os.environ.get('TV_SESSION'),
        signature=os.environ.get('TV_SIGNATURE')
    )
    
    print("正在连接到TradingView...")
    await client.connect()
    print("连接成功!")
    
    # 创建图表会话
    chart = client.Session.Chart()
    
    # 设置市场和参数
    print("正在加载比特币数据...")
    chart.set_market('BINANCE:BTCUSDT', {
        'timeframe': '1D'  # 日线图表
    })
    
    # 数据加载标志
    data_loaded = False
    
    # 定义错误处理函数
    def on_error(*err):
        print("发生错误:", *err)
        asyncio.create_task(client.end())
    
    # 定义交易对加载成功的回调
    def on_symbol_loaded():
        print(f"交易对 {chart.infos.description} 加载成功!")
        print(f"交易所: {chart.infos.exchange}")
        print(f"货币: {chart.infos.currency_id}")
    
    # 定义数据更新的回调
    def on_update():
        nonlocal data_loaded
        if data_loaded:
            return
            
        if not chart.periods:
            return
            
        print(f"已获取 {len(chart.periods)} 条K线数据")
        
        # 显示最新的K线数据
        latest = chart.periods[0]
        print("\n最新价格数据:")
        print(f"时间: {latest.time}")
        print(f"开盘价: {latest.open}")
        print(f"最高价: {latest.high}")
        print(f"最低价: {latest.low}")
        print(f"收盘价: {latest.close}")
        print(f"成交量: {latest.volume}")
        
        data_loaded = True
        print("\n5秒后将关闭连接...")
        asyncio.create_task(close_connection())
    
    # 注册回调函数
    chart.on_error(on_error)
    chart.on_symbol_loaded(on_symbol_loaded)
    chart.on_update(on_update)
    
    # 关闭连接的函数
    async def close_connection():
        await asyncio.sleep(5)
        print("正在关闭连接...")
        chart.delete()
        await client.end()
        print("连接已关闭!")
    
    # 等待操作完成
    try:
        await asyncio.sleep(30)  # 最多等待30秒
    except asyncio.CancelledError:
        pass

if __name__ == '__main__':
    asyncio.run(main())
```

## 第三步：运行第一个示例

在命令行中运行您的第一个脚本：

```bash
python first_example.py
```

如果一切正常，您将看到连接成功的消息，然后是比特币的最新价格数据。

## 第四步：获取历史K线数据

以下是获取历史K线数据的示例：

```python
#!/usr/bin/env python3
import asyncio
import os
import json
from datetime import datetime
from tradingview import Client

async def main():
    client = Client(
        token=os.environ.get('TV_SESSION'),
        signature=os.environ.get('TV_SIGNATURE')
    )
    
    await client.connect()
    
    # 创建图表会话
    chart = client.Session.Chart()
    
    # 设置市场和参数
    symbol = 'BINANCE:ETHUSDT'  # 以太坊/USDT
    timeframe = '60'  # 1小时K线
    klines_count = 200  # 获取200根K线
    
    print(f"正在获取 {symbol} 的 {timeframe}分钟K线数据...")
    
    chart.set_market(symbol, {
        'timeframe': timeframe,
        'range': klines_count
    })
    
    # 数据加载标志
    data_loaded = False
    
    # 错误处理函数
    def on_error(*err):
        print("发生错误:", *err)
        asyncio.create_task(client.end())
    
    # 交易对加载成功的回调
    def on_symbol_loaded():
        print(f"交易对 {chart.infos.description} 加载成功!")
    
    # 数据更新的回调
    def on_update():
        nonlocal data_loaded
        if data_loaded:
            return
            
        if not chart.periods:
            return
            
        print(f"已获取 {len(chart.periods)} 条K线数据")
        
        # 将数据转换为易于处理的格式
        klines = []
        for period in chart.periods:
            klines.append({
                'time': period.time,
                'datetime': datetime.fromtimestamp(period.time).isoformat(),
                'open': period.open,
                'high': period.high,
                'low': period.low,
                'close': period.close,
                'volume': period.volume
            })
        
        # 按时间排序
        klines.sort(key=lambda x: x['time'])
        
        # 打印第一条和最后一条数据
        print("\n第一条数据:")
        print(klines[0])
        
        print("\n最后一条数据:")
        print(klines[-1])
        
        # 保存到文件
        filename = f"{symbol.replace(':', '_')}_{timeframe}m_data.json"
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(klines, f, indent=2)
            
        print(f"\n数据已保存到文件: {filename}")
        
        data_loaded = True
        asyncio.create_task(close_connection())
    
    # 注册回调函数
    chart.on_error(on_error)
    chart.on_symbol_loaded(on_symbol_loaded)
    chart.on_update(on_update)
    
    # 关闭连接的函数
    async def close_connection():
        await asyncio.sleep(2)
        print("正在关闭连接...")
        chart.delete()
        await client.end()
        print("连接已关闭!")
    
    # 等待操作完成
    try:
        await asyncio.sleep(30)  # 最多等待30秒
    except asyncio.CancelledError:
        pass

if __name__ == '__main__':
    asyncio.run(main())
```

## 第五步：使用技术指标

以下是使用内置技术指标(EMA)的示例：

```python
#!/usr/bin/env python3
import asyncio
import os
from tradingview import Client, get_indicator

async def main():
    client = Client(
        token=os.environ.get('TV_SESSION'),
        signature=os.environ.get('TV_SIGNATURE')
    )
    
    await client.connect()
    
    # 创建图表会话
    chart = client.Session.Chart()
    
    # 设置市场
    chart.set_market('BINANCE:BTCUSDT', {
        'timeframe': '1D'
    })
    
    # 创建指标研究
    print("正在创建EMA指标...")
    
    ema_indicator = await get_indicator('STD;EMA')
    ema_indicator.set_option('Length', 20)  # 设置EMA周期为20
    
    ema_study = chart.Study(ema_indicator)
    
    # 定义错误处理函数
    def on_error(*err):
        print("发生错误:", *err)
        asyncio.create_task(client.end())
    
    # 定义图表更新的回调
    def on_chart_update():
        if not chart.periods:
            return
            
        print(f"图表数据已更新，获取到 {len(chart.periods)} 条K线数据")
    
    # 定义指标更新的回调
    def on_indicator_update():
        if not ema_study.periods:
            return
            
        print(f"EMA指标已更新，获取到 {len(ema_study.periods)} 条数据")
        
        # 显示最新几条数据对比
        for i in range(min(5, len(ema_study.periods))):
            period = ema_study.periods[i]
            chart_period = chart.periods[i] if i < len(chart.periods) else None
            
            if period and chart_period and period.time == chart_period.time:
                print(f"时间: {period.time} | 价格: {chart_period.close} | EMA20: {period.plot_0}")
        
        # 10秒后关闭连接
        asyncio.create_task(close_connection())
    
    # 注册回调函数
    chart.on_error(on_error)
    chart.on_update(on_chart_update)
    ema_study.on_update(on_indicator_update)
    
    # 关闭连接的函数
    async def close_connection():
        await asyncio.sleep(10)
        print("正在关闭连接...")
        chart.delete()
        await client.end()
        print("连接已关闭!")
    
    # 等待操作完成
    try:
        await asyncio.sleep(60)  # 最多等待60秒
    except asyncio.CancelledError:
        pass

if __name__ == '__main__':
    asyncio.run(main())
```

## 第六步：多交易对同步获取

以下是同时获取多个交易对数据的示例：

```python
#!/usr/bin/env python3
import asyncio
import os
from tradingview import Client

async def main():
    client = Client(
        token=os.environ.get('TV_SESSION'),
        signature=os.environ.get('TV_SIGNATURE')
    )
    
    await client.connect()
    
    # 创建多个图表会话
    btc_chart = client.Session.Chart()
    eth_chart = client.Session.Chart()
    
    # 设置不同的交易对
    btc_chart.set_market('BINANCE:BTCUSDT', {
        'timeframe': '1D'
    })
    
    eth_chart.set_market('BINANCE:ETHUSDT', {
        'timeframe': '1D'
    })
    
    # 数据获取计数
    data_count = 0
    
    # 定义错误处理函数
    def on_error(*err):
        print("发生错误:", *err)
        asyncio.create_task(client.end())
    
    # 比特币数据更新回调
    def on_btc_update():
        nonlocal data_count
        if not btc_chart.periods:
            return
            
        print(f"BTC数据已更新，最新价格: {btc_chart.periods[0].close} USDT")
        data_count += 1
        check_completion()
    
    # 以太坊数据更新回调
    def on_eth_update():
        nonlocal data_count
        if not eth_chart.periods:
            return
            
        print(f"ETH数据已更新，最新价格: {eth_chart.periods[0].close} USDT")
        data_count += 1
        check_completion()
    
    # 检查是否所有数据都已获取
    def check_completion():
        if data_count >= 2:  # 两个交易对都已获取数据
            print("\n所有数据获取完成！")
            
            # 计算BTC/ETH价格比
            btc_price = btc_chart.periods[0].close
            eth_price = eth_chart.periods[0].close
            ratio = btc_price / eth_price
            
            print(f"BTC/ETH价格比: {ratio:.2f}")
            
            # 关闭连接
            asyncio.create_task(close_connection())
    
    # 注册回调函数
    btc_chart.on_error(on_error)
    eth_chart.on_error(on_error)
    btc_chart.on_update(on_btc_update)
    eth_chart.on_update(on_eth_update)
    
    # 关闭连接的函数
    async def close_connection():
        await asyncio.sleep(5)
        print("正在关闭连接...")
        btc_chart.delete()
        eth_chart.delete()
        await client.end()
        print("连接已关闭!")
    
    # 等待操作完成
    try:
        await asyncio.sleep(30)  # 最多等待30秒
    except asyncio.CancelledError:
        pass

if __name__ == '__main__':
    asyncio.run(main())
```

## 常见问题解答

### 1. 认证失败怎么办？

- 确认session和signature是否正确
- 尝试重新登录TradingView网站获取新的认证信息
- 检查认证信息是否已过期（一般有效期为几天到几周）

### 2. 获取不到数据怎么办？

- 确认交易对格式是否正确（如'BINANCE:BTCUSDT'而非'BTCUSDT'）
- 检查时间周期是否有效（有效值如'1', '5', '15', '60', '1D'等）
- 确认交易所是否支持该交易对

### 3. 运行报错"WebSocket连接失败"怎么办？

- 检查网络连接是否正常
- 确认防火墙设置是否允许WebSocket连接
- 尝试使用代理或VPN（如果您所在地区限制访问TradingView）

### 4. 如何获取更多历史数据？

使用`fetch_more`方法：

```python
# 获取更多历史数据
await chart.fetch_more(5)  # 获取更多5个时间段的数据
```

### 5. 如何处理断线重连？

实现自动重连机制：

```python
async def maintain_connection(client):
    while True:
        try:
            if not client.is_open:
                print("连接断开，尝试重连...")
                await client.connect()
                print("重连成功!")
            
            await asyncio.sleep(30)  # 每30秒检查一次
        except Exception as e:
            print(f"重连失败: {str(e)}")
            await asyncio.sleep(10)  # 失败后等待10秒再试

# 启动连接维护任务
asyncio.create_task(maintain_connection(client))
```

## 下一步学习

恭喜您已经掌握了TradingView API客户端的基本使用方法！接下来您可以：

1. 尝试使用更多内置指标（如MACD、RSI、布林带等）
2. 探索Pine脚本指标的使用
3. 学习回放模式进行历史数据分析
4. 尝试搜索功能查找市场和指标
5. 深入了解图表绘制功能

更多高级用法请参考[TradingView API功能文档](TradingView功能文档.md)和[TradingView逻辑功能分析](TradingView逻辑功能分析.md)，或查看`examples`目录中的示例代码。

祝您使用愉快！ 